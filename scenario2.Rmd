---
title: "Scenario 2"
---

```{r, include=FALSE,}
knitr::opts_chunk$set(eval=FALSE, dpi=150, fig.path="figures/")
```

## Description

This example scenario describes a transient simulation (1995--2010) of the calibrated model
converting an existing parcel of irrigated land to non-irrigated status;
that is, the parcel is voluntarily allowed to go idle.
The land parcel (about 2.4 square kilometers or 600 acres) is shown in the following map:

| ![](images/scenario2-desc_01.png)

Changes to unprocessed-data files include:

* Irrigated lands ("extdata/irr/irr.lands.\<YYYY\>.zip")---changed parcel status to "non-irrigated".

* Evapotranspiration (ET)("extdata/et/et.\<YYYMM\>.tif")---reduced ET within the parcel
  and set equal to the monthly precipitation during the irrigation season.

* Combined surface-water irrigation diversions ("extdata/div/comb.sw.irr.csv")--removed
  diversions associated with wells in parcel.

* Groundwater points of diversion ("extdata/div/pod.gw.csv")---removed diversions for wells in parcel.

* Well sites ("extdata/div/pod.wells.zip")---removed sites located in parcel.

Files that did not need to be modified for this scenario,
but may want to consider modifying for similar model scenarios include:

  * Surface water diversions ("div.sw.csv")---we assumed surface water associated
    with the idled parcel is now delivered to other junior users within the same canal service area.

  * Groundwater diversions ("div.gw.csv")---if there had been *measured* groundwater diversions
    associated with the parcel, those would need to be removed.

## Create Datasets

The R script for creating the modified datasets (shown in code blocks) is
primarily based on embedded R code in appendix C.
It was necessary to alter the path names to the modified unprocessed-data files.
Because we're not re-creating all datasets in the *wrv* package,
we needed to be able to access the unmodified package datasets;
to do so, we used the following code syntax `wrv::<name.of.dataset>` to gain access to these datasets.

### Level 1 Data

Datasets processed at level 1.

#### Creating datasets preamble

Read text file for Appendix C R-source code and parse and evaluate the preamble in the current R session.

```{r app-c-r-1, message=FALSE}
file <- system.file("doc", "sir20165080_AppendixC.R", package = "wrv")
app.c.r <- readLines(file)
eval(parse(text = app.c.r[1:(grep("DownloadFile", app.c.r)[1] - 1)]))
```

#### Combined surface-water irrigation diversions (comb.sw.irr)

Read combined surface-water irrigation diversions data and
write its external representation as an R object in "data/comb.sw.irr.rda".

```{r comb-sw-irr-1}
file <- file.path(getwd(), "extdata/div/comb.sw.irr.csv")
comb.sw.irr <- read.csv(file, strip.white = TRUE)
comb.sw.irr$Pdate <- as.Date(comb.sw.irr$Pdate, format = "%m/%d/%Y")
comb.sw.irr$MaxDivRate <- comb.sw.irr$MaxDivRate * cfs.to.m3.per.d
save(comb.sw.irr, file = file.path(dir.dat, "comb.sw.irr.rda"), compress = "xz")
```

#### Points of diversion for groundwater (pod.gw)

Read points of diversion for groundwater data and
write its external representation as an R object in "data/pod.gw.csv.rda".

```{r pod-gw-1}
file <- file.path(getwd(), "extdata/div/pod.gw.csv")
d <- read.csv(file, strip.white = TRUE, stringsAsFactors = FALSE)
d$Pdate <- as.Date(d$PriorityDa, format = "%m/%d/%Y")
d$IrrRate <- d$IRRcfs * cfs.to.m3.per.d
columns <- c("WMISNumber", "WaterRight", "EntityName", "EntitySrce", "Pdate", "IrrRate")
pod.gw <- d[, columns]
save(pod.gw, file = file.path(dir.dat, "pod.gw.rda"), compress = "xz")
```

#### Well completions (pod.wells)

Read well completions data and initialize new variable in its data table.

```{r pod-wells-1}
file <- file.path(getwd(), "extdata/div/pod.wells.zip")
unzip(file, exdir=tempdir())
layer <- sub(".zip$", "", basename(file))
pod.wells <- readOGR(dsn = tempdir(), layer = layer, verbose = FALSE)
pod.wells <- spTransform(pod.wells, crs)
d <- pod.wells@data
columns <- c("TopOpen1", "BotOpen1", "TopOpen2", "BotOpen2")
d[, columns] <- d[, columns] * ft.to.m
d[d$TopOpen1 == 0 | d$BotOpen1 == 0, c("TopOpen1", "BotOpen1")] <- NA
d[d$TopOpen2 == 0 | d$BotOpen2 == 0, c("TopOpen2", "BotOpen2")] <- NA
```

A missing well completion is assumed identical to the completion of its nearest-neighbor well.

```{r pod-wells-2}
is.pred <- is.na(d$TopOpen1)
dists <- as.matrix(dist(coordinates(pod.wells)))
dists <- dists[!is.pred & d$WellUse %in% "Irrigation", ]
nearest.well <- as.integer(apply(dists, 2, function(i) names(which.min(i))))
d$TopOpen1[is.pred] <- d$TopOpen1[nearest.well[is.pred]]
d$BotOpen1[is.pred] <- d$BotOpen1[nearest.well[is.pred]]
columns <- c("WMISNumber", "WellUse", "TopOpen1", "BotOpen1", "TopOpen2", "BotOpen2")
pod.wells@data <- d[, columns]
```

Write its external representation as an R object in "data/pod.wells.rda".

```{r pod-wells-3}
save(pod.wells, file = file.path(dir.dat, "pod.wells.rda"), compress = "xz")
```

#### Irrigation lands (irr.lands)

Read irrigated and semi-irrigated lands data and
write its external representation as an R object in "data/irr.lands.rda".

```{r irr-lands-1}
files <- list.files(file.path(getwd(), "extdata/irr"), full.names = TRUE)
yr <- gsub("[^0-9]", "", files)
irr.lands <- list()
for (i in seq_along(files)) {
  unzip(files[i], exdir=tempdir())
  layer <- sub(".zip$", "", basename(files[i]))
  p <- readOGR(dsn = tempdir(), layer = layer, verbose = FALSE)
  p <- spTransform(p, crs)
  p@data <- p@data[, paste0("STATUS_", substr(yr[i], 1, 3)), drop = FALSE]
  names(p@data) <- "Status"
  p <- p[p@data[, "Status"] != "non-irrigated", ]
  p <- rgeos::gBuffer(p, width = 0, byid = TRUE)
  p@data <- droplevels(p@data)
  irr.lands[[i]] <- p
}
names(irr.lands) <- as.character(yr)
save(irr.lands, file = file.path(dir.dat, "irr.lands.rda"), compress = "xz")
```

#### Evapotranspiration (et)

Read evapotranspiration (ET) data and average by month.
Note that ET raster files (".tif") are required for every month in the simulation,
not just months with modified values.

```{r et-1}
files <- list.files(file.path(getwd(), "extdata/et"), full.names = TRUE)
FUN <- function(i) {
  r <- readGDAL(i, band = 1, silent = TRUE)
  raster::crs(r) <- crs
  r[[1]] <- r[[1]] * mm.to.m
  return(r)
}
et.raw <- lapply(files, FUN)
names(et.raw) <- as.character(yr.mo)
```

Project raster data into model grid and place an upper and lower limit on
ET that is 3 standard deviations from the mean value.

```{r et-2}
high.res.spatial.grid <- disaggregate(spatial.grid, fact = 5L)
is.missing <- is.na(wrv::alluvium.thickness)
FUN <- function(i) {
  r <- aggregate(projectRaster(raster(i), high.res.spatial.grid), fact = 5L)
  r[is.missing] <- NA
  upper.limit <- mean(r[], na.rm = TRUE) + sd(r[], na.rm = TRUE) * 3
  r[r > upper.limit] <- upper.limit
  return(round(r, digits = 6))
}
et <- stack(lapply(et.raw, FUN), quick = TRUE)
names(et) <- as.character(yr.mo)
```

Write its external representation as an R object in "data/et.rda".

```{r et-3}
save(et, file = file.path(dir.dat, "et.rda"), compress = "xz")
```

### Level 2 Data

Datasets processed at level 2 result from analysis of level 1 data.

#### Monthly irrigation entity components (entity.components)

Irrigation entities and their components.
Start with the spatial polygon representing the irrigated lands and
remove those areas that are designated as wetlands or public parcels.
Intersect the resulting polygon with the irrigation entities and calculate the area for each entity.

```{r entity-components-1}
p <- irr.lands
p <- lapply(p, function(i) inlmisc::SetPolygons(i, wrv::wetlands, "gDifference", 0.001))
p <- lapply(p, function(i) inlmisc::SetPolygons(i, wrv::public.parcels, "gDifference", 0.001))
p <- lapply(p, function(i) inlmisc::SetPolygons(wrv::irr.entities, i, "gIntersection", 0.001))
for (i in seq_along(p)) p[[i]]@data$area <- rgeos::gArea(p[[i]], byid = TRUE)
irr.by.entity <- p
```

Irrigation entities are subdivided by water source; that is, "surface-water only", "groundwater only", or "mixed source".
Aggregate irrigation entities by water source and calculate their area.

```{r entity-components-2}
FUN <- function(i) {
  d <- aggregate(i@data$area, by = list(i@data$EntitySrce), sum, na.rm = TRUE)
  names(d) <- c("EntitySrce", "area")
  FUN <- function(j) as.character(i@data$PrecipZone[i@data$EntitySrce == j][1])
  d$PrecipZone <- as.factor(vapply(d$EntitySrce, FUN, ""))
  return(d)
}
area.by.entity <- lapply(irr.by.entity, FUN)
```

Calculate the volumetric components of ET, precipitation, and crop irrigation requirement
for each irrigation entity and water source.

```{r entity-components-3}
FUN <- function(i) {
  yr <- wrv::irr.lands.year$IL_Year[wrv::irr.lands.year$Year %in% substr(i, 1, 4)]
  p <- irr.by.entity[[yr]]
  unique.sources <- sort(unique(as.character(p@data$EntitySrce)))
  FUN <- function (j) {
    x <- rgeos::gUnaryUnion(p[p@data$EntitySrce == j, ])@polygons[[1]]
    slot(x, "ID") <- j
    return(x)
  }
  sp <- SpatialPolygons(lapply(unique.sources, FUN), proj4string = crs(et.raw[[i]]))
  p <- over(sp, et.raw[[i]], fn = mean, na.rm = TRUE)
  d <- as.data.frame(list(EntitySrce = rownames(p), mean.et = p[, 1]))
  d <- suppressWarnings(dplyr::left_join(d, area.by.entity[[yr]], by = "EntitySrce"))
  d$et.vol <- d$mean.et * d$area
  d$precip.vol <- NA
  for (j in levels(d$PrecipZone)) {
    is.in.zone <- d$PrecipZone == j
    idx <- which(wrv::precipitation$YearMonth == i & wrv::precipitation$PrecipZone == j)
    d$precip.vol[is.in.zone] <- d$area[is.in.zone] * wrv::precipitation$Precip[idx]
  }
  d$cir.vol <- d$et.vol - d$precip.vol
  idxs <- match(d$EntitySrce, wrv::irr.entities@data$EntitySrce)
  d[, c("EntityName", "Source")] <- wrv::irr.entities@data[idxs, c("EntityName", "Source")]
  rownames(d) <- d$EntitySrce
  return(SpatialPolygonsDataFrame(sp, d))
}
entity.components <- lapply(yr.mo, FUN)
names(entity.components) <- yr.mo
```

Write its external representation as an R object in "data/entity.components.rda".

```{r entity-components-4}
save(entity.components, file = file.path(dir.dat, "entity.components.rda"), compress = "xz")
```

## Process Model

Something

### Pre-processing

Something

```{r r-env-1, message=FALSE, eval=TRUE}
rm(list = ls())
files <- list.files(file.path(getwd(), "data"), patter = "*.rda$", full.names = TRUE)
for (i in files) load(i)
```

Something

```{r app-d-r-1, eval=TRUE}
file <- system.file("doc", "sir20165080_AppendixD.R", package = "wrv")
app.d.r <- readLines(file)
app.d.r <- app.d.r[-grep("invisible.*dev.off", app.d.r)]
```

Something

```{r app-d-r-2, collapse=TRUE, message=FALSE, results="hide", fig.keep="none", eval=TRUE}
line <- grep("## ----write_modflow_input", app.d.r)
eval(parse(text = app.d.r[1:line]))
app.d.r <- app.d.r[-(1:line)]
line <- grep("## ----", app.d.r)[1] - 1
app.d.r <- app.d.r[-(1:line)]
```

Something

```{r app-d-r-3, eval=TRUE}
id <- "wrv_mfusg"
dir.run <- file.path(getwd(), "model")
```

Something

```{r app-d-r-4, results="hide"}
WriteModflowInput(rs.model, rech, well, trib, misc, river, drain, id, dir.run,
                  is.convertible = FALSE, tr.stress.periods = tr.stress.periods,
                  ntime.steps = ntime.steps, verbose = FALSE)
```

Something

```{r app-d-r-5, results="hide"}
url <- "http://water.usgs.gov/GIS/dsdl/gwmodels/SIR2016-5080/model.zip"
file <- file.path(tempdir(), basename(file))
download.file(url, file)
files <- unzip(file, exdir = tempdir())
file.copy(files[grep("\\.ref$", files)], dir.run, overwrite = TRUE)
```

### Run model

Something

```{r app-d-r-6}
line <- grep("## ----read_budget", app.d.r)
eval(parse(text = app.d.r[1:line]))
```

### Post-processing

Something

```{r app-d-r-7, eval=TRUE}
line <- grep("## ----read_budget", app.d.r)
app.d.r <- app.d.r[-(1:line)]
line <- grep("## ----graph_budget", app.d.r)
eval(parse(text = app.d.r[1:line]))
app.d.r <- app.d.r[-(1:line)]
```





